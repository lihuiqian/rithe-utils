import Predicate from "../fp/Predicate";
import Project from "../fp/Project";
declare function empty<K extends keyof any, V>(): Record<K, V>;
declare function of<K extends keyof any, V>(record: Record<K, V>): Record<K, V>;
declare function from<K extends keyof any, V>(iterable: Iterable<[K, V]>): Record<K, V>;
declare function concat<K extends keyof any, V>(...records: Record<K, V>[]): Record<K, V>;
declare function forEach<K extends keyof any, V>(record: Record<K, V>, callbackFn: (value: V, key: K, record: Record<K, V>) => void): void;
declare function entries<K extends keyof any, V>(record: Record<K, V>): Iterable<[K, V]>;
declare function keys<K extends keyof any>(record: Record<K, unknown>): Iterable<K>;
declare function values<V>(record: Record<keyof any, V>): Iterable<V>;
declare function transform<K extends keyof any, V, T>(record: Record<K, V>, valueProject: Project<V, T>): Record<K, T>;
declare function filter<K extends keyof any, V>(record: Record<K, V>, predicate: Predicate<[K, V]>): Record<K, V>;
declare function size<K extends keyof any, V>(record: Record<K, V>): number;
declare function elementsEqual<K extends keyof any, V>(record1: Record<K, V>, record2: Record<K, V>): boolean;
declare function set<K extends keyof any, V>(record: Record<K, V>, ...entries: [K, V][]): Record<K, V>;
declare function _delete<K extends keyof any, V>(record: Record<K, V>, ...keys: K[]): Record<K, V>;
declare const _default: {
    EMPTY: Record<string | number | symbol, unknown>;
    empty: typeof empty;
    of: typeof of;
    from: typeof from;
    concat: typeof concat;
    forEach: typeof forEach;
    entries: typeof entries;
    keys: typeof keys;
    values: typeof values;
    transform: typeof transform;
    filter: typeof filter;
    size: typeof size;
    elementsEqual: typeof elementsEqual;
    set: typeof set;
    delete: typeof _delete;
};
export default _default;
