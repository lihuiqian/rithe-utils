import Multimap from "../collect/Multimap";
import Multiset from "../collect/Multiset";
import BiConsumer from "./BiConsumer";
import BiPredicate from "./BiPredicate";
import BiProject from "./BiProject";
import Consumer from "./Consumer";
import Predicate from "./Predicate";
import Project from "./Project";
import Supplier from "./Supplier";
interface HOF {
    alwaysNull(): () => undefined;
    alwaysTrue(): () => true;
    alwaysFalse(): () => false;
    alwaysZero(): () => 0;
    alwaysVoid(): () => void;
    identity(): <T>(t: T) => T;
    isNull(): <T>(t: T | undefined | null) => boolean;
    notNull(): <T>(t: T | undefined | null) => boolean;
    getLeft(): <T>(t: T, _: T) => T;
    getRight(): <T>(t: T, _: T) => T;
    getOrDefault(): <T>(t: T, _: T) => T;
    zip(): <T>(t1: T, t2: T) => [T, T];
    constant<T>(c: T): Supplier<T>;
    forArray<T>(array: T[]): Project<number, T | undefined>;
    forArray<T>(array: T[], defaultValue: T): Project<number, T>;
    forMap<K, V>(map: Map<K, V>): Project<K, V | undefined>;
    forMap<K, V>(map: Map<K, V>, defaultValue: V): Project<K, V>;
    forRecord<K extends string | number | symbol, V>(record: Record<K, V>): Project<K, V | undefined>;
    forRecord<K extends string | number | symbol, V>(record: Record<K, V>, defaultValue: V): Project<K, V>;
    forMultiset<T>(multiset: Multiset<T>): Project<T, number>;
    memberOf<T>(iterable: Iterable<T>): Predicate<T>;
    keyOf<K, V>(map: Map<K, V>): Predicate<K>;
    keyOf<K>(multimap: Multimap<K, unknown>): Predicate<K>;
    propertyOf<K extends string | number | symbol>(record: Record<K, unknown>): Predicate<K>;
    valueOf<V>(map: Map<unknown, V>): Predicate<V>;
    valueOf<V>(multimap: Multimap<unknown, V>): Predicate<V>;
    valueOf<V>(record: Record<any, V>): Predicate<V>;
    instanceOf<T>(constructor: Function): Predicate<T>;
    assignableFrom<T>(constructor: Function): Predicate<T>;
    subtypeOf<T>(constructor: Function): Predicate<T>;
    equalsTo<T>(value: T): Predicate<T>;
    maybe<T, R>(project: Project<T, R>): Project<T | undefined | null, R | undefined | null>;
    not<T>(predicate: Predicate<T>): Predicate<T>;
    not<T, U>(predicate: BiPredicate<T, U>): BiPredicate<T, U>;
    and<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    and<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    or<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    or<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    xor<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    xor<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    nand<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    nand<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    nor<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    nor<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    xnor<T>(predicate1: Predicate<T>, predicate2: Predicate<T>): Predicate<T>;
    xnor<T, U>(predicate1: BiPredicate<T, U>, predicate2: BiPredicate<T, U>): BiPredicate<T, U>;
    concat<T>(...consumers: Consumer<T>[]): Consumer<T>;
    concat<T, U>(...consumers: BiConsumer<T, U>[]): BiConsumer<T, U>;
    compose<B, C>(fn2: Project<B, C>, fn1: Supplier<B>): Supplier<C>;
    compose<A, B, C>(fn2: Project<B, C>, fn1: Project<A, B>): Project<A, C>;
    compose<A1, A2, B, C>(fn2: Project<B, C>, fn1: BiProject<A1, A2, B>): BiProject<A1, A2, C>;
    compose<B, C, D>(fn3: Project<C, D>, fn2: Project<B, C>, fn1: Supplier<B>): Supplier<D>;
    compose<A, B, C, D>(fn3: Project<C, D>, fn2: Project<B, C>, fn1: Project<A, B>): Project<A, D>;
    compose<A1, A2, B, C, D>(fn3: Project<C, D>, fn2: Project<B, C>, fn1: BiProject<A1, A2, B>): BiProject<A1, A2, D>;
    compose<B, C, D, E>(fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: Supplier<B>): Supplier<E>;
    compose<A, B, C, D, E>(fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: Project<A, B>): Project<A, E>;
    compose<A1, A2, B, C, D, E>(fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: BiProject<A1, A2, B>): BiProject<A1, A2, E>;
    compose<B, C, D, E, F>(fn5: Project<E, F>, fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: Supplier<B>): Supplier<F>;
    compose<A, B, C, D, E, F>(fn5: Project<E, F>, fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: Project<A, B>): Project<A, F>;
    compose<A1, A2, B, C, D, E, F>(fn5: Project<E, F>, fn4: Project<D, E>, fn3: Project<C, D>, fn2: Project<B, C>, fn1: BiProject<A1, A2, B>): BiProject<A1, A2, F>;
    pipe<B, C>(fn1: Supplier<B>, fn2: Project<B, C>): Supplier<C>;
    pipe<A, B, C>(fn1: Project<A, B>, fn2: Project<B, C>): Project<A, C>;
    pipe<A1, A2, B, C>(fn1: BiProject<A1, A2, B>, fn2: Project<B, C>): BiProject<A1, A2, C>;
    pipe<B, C, D>(fn1: Supplier<B>, fn2: Project<B, C>, fn3: Project<C, D>): Supplier<D>;
    pipe<A, B, C, D>(fn1: Project<A, B>, fn2: Project<B, C>, fn3: Project<C, D>): Project<A, D>;
    pipe<A1, A2, B, C, D>(fn1: BiProject<A1, A2, B>, fn2: Project<B, C>, fn3: Project<C, D>): BiProject<A1, A2, D>;
    pipe<B, C, D, E>(fn1: Supplier<B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>): Supplier<E>;
    pipe<A, B, C, D, E>(fn1: Project<A, B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>): Project<A, E>;
    pipe<A1, A2, B, C, D, E>(fn1: BiProject<A1, A2, B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>): BiProject<A1, A2, E>;
    pipe<B, C, D, E, F>(fn1: Supplier<B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>, fn5: Project<E, F>): Supplier<F>;
    pipe<A, B, C, D, E, F>(fn1: Project<A, B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>, fn5: Project<E, F>): Project<A, F>;
    pipe<A1, A2, B, C, D, E, F>(fn1: BiProject<A1, A2, B>, fn2: Project<B, C>, fn3: Project<C, D>, fn4: Project<D, E>, fn5: Project<E, F>): BiProject<A1, A2, F>;
}
declare const hof: HOF;
export default hof;
