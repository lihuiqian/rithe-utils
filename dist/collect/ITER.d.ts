import { ArrayMultimap } from "..";
import Comparator from "../base/Comparator";
import Multiset from "./Multiset";
import SetMultimap from "./SetMultimap";
declare function iter<T>(array: T[]): FluentArray<T>;
declare function iter<T>(set: Set<T>): FluentSet<T>;
declare function iter<T>(multiset: Multiset<T>): FluentMultiset<T>;
declare function iter<K, V>(map: Map<K, V>): FluentMap<K, V>;
declare function iter<K, V>(multimap: ArrayMultimap<K, V>): FluentArrayMultimap<K, V>;
declare function iter<K, V>(multimap: SetMultimap<K, V>): FluentSetMultimap<K, V>;
declare function iter<T>(iterable: Iterable<T>): FluentIterable<T>;
declare class FluentIterable<T> {
    readonly value: Iterable<T>;
    constructor(iterable: Iterable<T>);
    private _call;
    concat(...iterables: Iterable<T>[]): FluentIterable<T>;
    zip(...iterables: Iterable<T>[]): FluentIterable<T[]>;
    map<R>(project: (value: T, index: number) => R): FluentIterable<R>;
    pairwise(): FluentIterable<[T, T]>;
    scan(accumulator: (acc: T, value: T, index: number) => T, initial?: T): FluentIterable<T>;
    scan<R>(accumulator: (acc: R, value: T, index: number) => R, initial: R): FluentIterable<R>;
    buffer(count: number, step?: number): FluentIterable<T[]>;
    flatMap<R>(project: (value: T, index: number) => R[]): FluentIterable<R>;
    skip(count: number): FluentIterable<T>;
    skipLast(count: number): FluentIterable<T>;
    take(count: number): FluentIterable<T>;
    takeLast(count: number): FluentIterable<T>;
    filter(predicate: (value: T, index: number) => boolean): FluentIterable<T>;
    reverse(): FluentIterable<T>;
    sort(comparator: Comparator<T>): FluentIterable<T>;
    distinct(): FluentIterable<T>;
    partition(size: number): FluentIterable<T>[];
    forEach(consumer: (value: T, index: number) => void): void;
    reduce(accumulator: (acc: T, value: T, index: number) => T): T | undefined;
    reduce(accumulator: (acc: T, value: T, index: number) => T, initial: T): T;
    asArray(): FluentArray<T>;
    asArray<R>(project: (value: T, index: number) => R): FluentArray<R>;
    asSet(): FluentSet<T>;
    asSet<R>(project: (value: T, index: number) => R): FluentSet<R>;
    asMultiset(): FluentMultiset<T>;
    asMultiset<R>(project: (value: T, index: number) => R): FluentMultiset<R>;
    asMap<K, V>(project: (value: T, index: number) => [K, V]): FluentMap<K, V>;
    asArrayMultimap<K, V>(project: (value: T, index: number) => [K, V]): FluentArrayMultimap<K, V>;
    asSetMultimap<K, V>(project: (value: T, index: number) => [K, V]): FluentSetMultimap<K, V>;
}
declare class FluentArray<T> {
    readonly value: T[];
    constructor(array: T[]);
    private _call;
    concat(...arrays: T[][]): FluentArray<T>;
    zip(...arrays: T[][]): FluentArray<T[]>;
    map<R>(project: (value: T, index: number) => R): FluentArray<R>;
    pairwise(): FluentArray<[T, T]>;
    scan(accumulator: (acc: T, value: T, index: number) => T, initial?: T): FluentArray<T>;
    scan<R>(accumulator: (acc: R, value: T, index: number) => R, initial: R): FluentArray<R>;
    buffer(count: number, step?: number): FluentArray<T[]>;
    flatMap<R>(project: (value: T, index: number) => R[]): FluentArray<R>;
    skip(count: number): FluentArray<T>;
    skipLast(count: number): FluentArray<T>;
    take(count: number): FluentArray<T>;
    takeLast(count: number): FluentArray<T>;
    filter(predicate: (value: T, index: number) => boolean): FluentArray<T>;
    reverse(): FluentArray<T>;
    sort(comparator: Comparator<T>): FluentArray<T>;
    distinct(): FluentArray<T>;
    partition(size: number): FluentArray<T>[];
    forEach(consumer: (value: T, index: number) => void): void;
    reduce(accumulator: (acc: T, value: T, index: number) => T): T | undefined;
    reduce(accumulator: (acc: T, value: T, index: number) => T, initial: T): T;
    fill(item: T, start?: number, end?: number): FluentArray<T>;
    push(...items: T[]): FluentArray<T>;
    unshift(...items: T[]): FluentArray<T>;
    pop(size?: number): FluentArray<T>;
    shift(size?: number): FluentArray<T>;
    splice(start: number, deleteCount?: number): FluentArray<T>;
    splice(start: number, deleteCount: number, ...items: T[]): FluentArray<T>;
    slice(start?: number, end?: number): FluentArray<T>;
    asIterable(): FluentIterable<T>;
    asIterable<R>(project: (value: T, index: number) => R): FluentIterable<R>;
    asSet(): FluentSet<T>;
    asSet<R>(project: (value: T, index: number) => R): FluentSet<R>;
    asMultiset(): FluentMultiset<T>;
    asMultiset<R>(project: (value: T, index: number) => R): FluentMultiset<R>;
    asMap<K, V>(project: (value: T, index: number) => [K, V]): FluentMap<K, V>;
    asArrayMultimap<K, V>(project: (value: T, index: number) => [K, V]): FluentArrayMultimap<K, V>;
    asSetMultimap<K, V>(project: (value: T, index: number) => [K, V]): FluentSetMultimap<K, V>;
}
declare class FluentSet<T> {
    readonly value: Set<T>;
    constructor(set: Set<T>);
    private _call;
    concat(...sets: Set<T>[]): FluentSet<T>;
    union(set: Set<T>): FluentSet<T>;
    intersection(set: Set<T>): FluentSet<T>;
    difference(set: Set<T>): FluentSet<T>;
    sysmmetricDifference(set: Set<T>): FluentSet<T>;
    map<R>(project: (value: T) => R): FluentSet<R>;
    flatMap<R>(project: (value: T) => R[]): FluentSet<R>;
    filter(predicate: (value: T) => boolean): FluentSet<T>;
    partition(size: number): FluentSet<T>[];
    forEach(consumer: (value: T) => void): void;
    add(...items: T[]): FluentSet<T>;
    delete(...items: T[]): FluentSet<T>;
    asIterable(): FluentIterable<T>;
    asIterable<R>(project: (value: T) => R): FluentIterable<R>;
    asArray(): FluentArray<T>;
    asArray<R>(project: (value: T) => R): FluentArray<R>;
    asMultiset(): FluentMultiset<T>;
    asMultiset<R>(project: (value: T) => R): FluentMultiset<R>;
    asMap<K, V>(project: (value: T) => [K, V]): FluentMap<K, V>;
    asArrayMultimap<K, V>(project: (value: T) => [K, V]): FluentArrayMultimap<K, V>;
    asSetMultimap<K, V>(project: (value: T) => [K, V]): FluentSetMultimap<K, V>;
}
declare class FluentMultiset<T> {
    readonly value: Multiset<T>;
    constructor(multiset: Multiset<T>);
    private _call;
    concat(...multisets: Multiset<T>[]): FluentMultiset<T>;
    union(set: Multiset<T>): FluentMultiset<T>;
    intersection(set: Multiset<T>): FluentMultiset<T>;
    difference(set: Multiset<T>): FluentMultiset<T>;
    sysmmetricDifference(set: Multiset<T>): FluentMultiset<T>;
    retainOccurrences(set: Multiset<T>): FluentMultiset<T>;
    map<R>(project: (value: T) => R): FluentMultiset<R>;
    flatMap<R>(project: (value: T) => R[]): FluentMultiset<R>;
    filter(predicate: (value: T) => boolean): FluentMultiset<T>;
    filterEntries(predicate: (value: T, count: number) => boolean): FluentMultiset<T>;
    sortByCount(comparator: Comparator<number>): FluentMultiset<T>;
    distinct(): FluentMultiset<T>;
    partition(size: number): FluentMultiset<T>[];
    forEach(consumer: (value: T) => void): void;
    add(...items: T[]): FluentMultiset<T>;
    delete(...items: T[]): FluentMultiset<T>;
    setCount(item: T, count: number): FluentMultiset<T>;
    asIterable(): FluentIterable<T>;
    asIterable<R>(project: (value: T) => R): FluentIterable<R>;
    asArray(): FluentArray<T>;
    asArray<R>(project: (value: T) => R): FluentArray<R>;
    asSet(): FluentSet<T>;
    asSet<R>(project: (value: T) => R): FluentSet<R>;
    asMap<K, V>(project: (value: T) => [K, V]): FluentMap<K, V>;
    asArrayMultimap<K, V>(project: (value: T) => [K, V]): FluentArrayMultimap<K, V>;
    asSetMultimap<K, V>(project: (value: T) => [K, V]): FluentSetMultimap<K, V>;
}
declare class FluentMap<K, V> {
    readonly value: Map<K, V>;
    constructor(map: Map<K, V>);
    private _call;
    concat(...maps: Map<K, V>[]): FluentMap<K, V>;
    transform<T>(project: (entry: [K, V]) => T): FluentMap<K, T>;
    filter(predicate: (entry: [K, V]) => boolean): FluentMap<K, V>;
    forEach(consumer: (entry: [K, V]) => void): void;
    set(...entries: [K, V][]): FluentMap<K, V>;
    delete(...keys: K[]): FluentMap<K, V>;
    asIterable(): FluentIterable<[K, V]>;
    asIterable<R>(project: (entry: [K, V]) => R): FluentIterable<R>;
    asArray(): FluentArray<[K, V]>;
    asArray<R>(project: (entry: [K, V]) => R): FluentArray<R>;
    asSet(): FluentSet<[K, V]>;
    asSet<R>(project: (entry: [K, V]) => R): FluentSet<R>;
    asMultiset(): FluentMultiset<[K, V]>;
    asMultiset<R>(project: (entry: [K, V]) => R): FluentMultiset<R>;
    asArrayMultimap(): FluentArrayMultimap<K, V>;
    asArrayMultimap<T>(project: (entry: [K, V]) => T): FluentArrayMultimap<K, T>;
    asSetMultimap(): FluentSetMultimap<K, V>;
    asSetMultimap<T>(project: (entry: [K, V]) => T): FluentSetMultimap<K, T>;
}
declare class FluentArrayMultimap<K, V> {
    readonly value: ArrayMultimap<K, V>;
    constructor(multimap: ArrayMultimap<K, V>);
    private _call;
    concat(...multimaps: ArrayMultimap<K, V>[]): FluentArrayMultimap<K, V>;
    transform<T>(project: (entry: [K, V]) => T): FluentArrayMultimap<K, T>;
    filter(predicate: (entry: [K, V]) => boolean): FluentArrayMultimap<K, V>;
    filterCollections(predicate: (entry: [K, V[]]) => boolean): FluentArrayMultimap<K, V>;
    forEach(consumer: (entry: [K, V]) => void): void;
    set(...entries: [K, V][]): FluentArrayMultimap<K, V>;
    delete(...entries: [K, V[]][]): FluentArrayMultimap<K, V>;
    asIterable(): FluentIterable<[K, V]>;
    asIterable<R>(project: (entry: [K, V]) => R): FluentIterable<R>;
    asArray(): FluentArray<[K, V]>;
    asArray<R>(project: (entry: [K, V]) => R): FluentArray<R>;
    asSet(): FluentSet<[K, V]>;
    asSet<R>(project: (entry: [K, V]) => R): FluentSet<R>;
    asMultiset(): FluentMultiset<[K, V]>;
    asMultiset<R>(project: (entry: [K, V]) => R): FluentMultiset<R>;
    asMap(): FluentMap<K, V>;
    asMap<T>(project: (entry: [K, V]) => T): FluentMap<K, T>;
    asSetMultimap(): FluentSetMultimap<K, V>;
    asSetMultimap<T>(project: (entry: [K, V]) => T): FluentSetMultimap<K, T>;
}
declare class FluentSetMultimap<K, V> {
    readonly value: SetMultimap<K, V>;
    constructor(multimap: SetMultimap<K, V>);
    private _call;
    concat(...multimaps: SetMultimap<K, V>[]): FluentSetMultimap<K, V>;
    transform<T>(project: (entry: [K, V]) => T): FluentSetMultimap<K, T>;
    filter(predicate: (entry: [K, V]) => boolean): FluentSetMultimap<K, V>;
    filterCollections(predicate: (entry: [K, Set<V>]) => boolean): FluentSetMultimap<K, V>;
    forEach(consumer: (entry: [K, V]) => void): void;
    set(...entries: [K, V][]): FluentSetMultimap<K, V>;
    delete(...entries: [K, Set<V>][]): FluentSetMultimap<K, V>;
    asIterable(): FluentIterable<[K, V]>;
    asIterable<R>(project: (entry: [K, V]) => R): FluentIterable<R>;
    asArray(): FluentArray<[K, V]>;
    asArray<R>(project: (entry: [K, V]) => R): FluentArray<R>;
    asSet(): FluentSet<[K, V]>;
    asSet<R>(project: (entry: [K, V]) => R): FluentSet<R>;
    asMultiset(): FluentMultiset<[K, V]>;
    asMultiset<R>(project: (entry: [K, V]) => R): FluentMultiset<R>;
    asMap(): FluentMap<K, V>;
    asMap<T>(project: (entry: [K, V]) => T): FluentMap<K, T>;
    asArrayMultimap(): FluentArrayMultimap<K, V>;
    asArrayMultimap<T>(project: (entry: [K, V]) => T): FluentArrayMultimap<K, T>;
}
export default iter;
